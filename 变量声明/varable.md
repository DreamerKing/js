# 声明提升

易用性原则

- 函数返回值、函数参数和变量无需指定类型的原因。
- 函数声明的顺序无关紧要。


比较点：

- 可变性
- 可重复性
- 作用域

- var 声明的变量在距离最近的函数内部(非箭头函数)或全局词法环境中(忽略块级作用域)
- function 声明的函数

在函数作用域或全局作用域中通过`var`声明的变量,无论在哪里声明都会被当成在`当前作用域顶部声明的变量`,其`初始化操作依旧留在原处执行`。

块级声明(词法作用域)
块级作用域绑定的 let 和 const 为 js 引入了词法作用域,它 们声明的变量不会提升,而且只能在声明这些变量的代码块中使用。
块级声明用于声明在指定块的作用域之外无法访问的变量。它存在于:

- 函数内部
- 块 `{}`内部
  使用`let`或`const`可以声明块作用域,并且不会被提升。
  在同一块作用域中`禁止重声明`,无论是使用`var`声明的还是`let`或`const`声明的。
  使用`const`声明的是常量，其值必须在声明时进行初化并且之后不可更改,无论在严格模式还非严格模式下。使用`const`声明对象,不允许修改绑定，但允许修改绑定的值(对象属性)。
  const 不能用在普通 for 循环的循环变量声明中,但在 for-in 和 for-of 循环中与 let 声明的循环变量表现一致。这是因为在 for-in 和 for-of 循环中,在每次迭代中不会修改已有的绑定,而会创建一个新的绑定。

临时死区(Temporal dead zone TDZ)
与 var 不同,使用`let`或`const`声明的变量不会被提升到作用域顶部，如果在声明之访问这些变量,即使是相对安全的 typeof 操作符也会触发引用错误,即不能在声明变量之前访问。

块级作用域特色：

- 临时死区
- 循环中的块作用域

全局块作用域绑定
let 和 const 与 var 在全局作用域中的行为不同。当 var 被用于全局作用域时，它会创建一个全局变量作为全局对象的属性,这有可能覆盖一个已存在的全局属性。而在全局作用域使用 let 或 const,只会在全局作用域下创建一个新的绑定,但该绑定不会被添加为全局对象属性。也即是不能覆盖全局变量，只能遮蔽它。

块级绑定最佳实践
默认使用 const,只在确实需要改变变量的值时使用 let。防止预料之外变量值改变引发的错误。

同一作用域内不允许重复声明

嵌套函数

## 重复声明

在同一块作用域内不允许重复声明具有跟 const/let 要声明的同名变量，即使是使用 var 声明也不行；但 var 可以声明的同名变量(也是使用 var 的声明的)，后声明的覆盖之前声明的。

js 中变量声明与值的类型无关，变量只是存储值的一个容器，可以用来保存任何类型的值。

var 声明变量的特征

- 不具有块作用域，使用的是函数作用域；
- 在所有函数体外声明的是全局变量，会被挂载为全局对象的属性，可以通过 globalThis 引用，并且这个属性还不能通过 delete 操作符删除。
- 允许使用 var 多次声明同名变量。
- 会作用域提升。在使用 var 声明变量时，该声明会被提升到包含函数的顶部。但变量的初始化仍然在代码的初始位置完成，只有变量定义转移到了函数顶部。因此对使用 var 声明的变量，可以在包含函数内部任何地方使用而不会报错。如果初始化代码未执行，变量的值可能是 undefined。

## 使用未声明的变量

在严格模式下，如果使用未声明的变量会触发引用错误。但在严格模式外部，如果将一个值赋给尚未使用 let、const 或 var 声明的标识符，则会创建一个全新的全局变量。而且不论这个赋值语句在函数或代码块嵌套层次多深，都会创建一个全局变量。以这种意外方式创建的全局变量类似使用 var 声明的全局变量，都定义全局对象的属性。但与通过恰当的 var 声明定义的属性不同，这些属性可以通过 delete 操作符删除。
