变量声明提升 
在函数作用域或全局作用域中通过`var`声明的变量,无论在哪里声明都会被当成在`当前作用域顶部声明的变量`,其`初始化操作依旧留在原处执行`。

块级声明(词法作用域)
块级作用域绑定的let和const为js引入了词法作用域,他们声明的变量不会提升,而且只能在声明这些变量的代码块中使用。
块级声明用于声明在指定块的作用域之外无法访问的变量。它存在于:
+ 函数内部
+ 块 `{}`内部
使用`let`或`const`可以声明块作用域,并且不会被提升。
在同一块作用域中`禁止重声明`,无论是使用`var`声明的还是`let`或`const`声明的。
使用`const`声明的是常量，其值必须在声明时进行初化并且之后不可更改,无论在严格模式还非严格模式下。使用`const`声明对象,不允许修改绑定，但允许修改绑定的值(对象属性)。
const不能用在普通for循环的循环变量声明中,但在for-in和for-of循环中与let声明的循环变量表现一致。这是因为在for-in和for-of循环中,在每次迭代中不会修改已有的绑定,而会创建一个新的绑定。

临时死区(Temporal dead zone TDZ) 
与var不同,使用`let`或`const`声明的变量不会被提升到作用域顶部，如果在声明之访问这些变量,即使是相对安全的typeof操作符也会触发引用错误,即不能在声明变量之前访问。

块级作用域特色：
+ 临时死区
+ 循环中的块作用域

全局块作用域绑定
let和const与var在全局作用域中的行为不同。当var被用于全局作用域时，它会创建一个全局变量作为全局对象的属性,这有可能覆盖一个已存在的全局属性。而在全局作用域使用let或const,只会在全局作用域下创建一个新的绑定,但该绑定不会被添加为全局对象属性。也即是不能覆盖全局变量，只能遮蔽它。

块级绑定最佳实践
默认使用const,只在确实需要改变变量的值时使用let。防止预料之外变量值改变引发的错误。
