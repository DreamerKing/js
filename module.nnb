{
    "cells": [
        {
            "language": "markdown",
            "source": [
                "# 模块\n\n通过模块可便捷的将代码分成小的、可维护的片段并按需组合在一起。\n\n- 将代码放入全局命名空间\n- 将代码封装在一个作用域函数中，这个函数可能会返回一个对象，然后将这个对象赋值给全局变量\n\n问题:\n- 命名冲突\n- 复杂的依赖关系\n- 代码分割成适当大小\n- 不同模块间的兼容问题"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## ESM模块基本概念\n\n模块是其自身\"编译单元\"中的代码单元。它有自己的作用域(非全局作用域);可以加载其他模块，并从中导入内容;也可以导出内容供其他模块导入。相互导入、导出的模块组成了模块树。\n\n一个模块在每个领域只会加载一次，多个模块使用了同一模块，都会使用同一个副本。\n一个模块可包含多个命名导出以及单个默认导出。\nexport和import声明只能出现在模块的顶层作用域，不能出现在任何控制流结构中。\n模块只能导出它声明的内容或重新导出它导入的内容，如不能导出一个全局变量。\n模块中不能声明一个全局变量，但可访问全局变量，可通过赋值的方式给全局对象添加属性。\n模块可读取它导入的值，即是原始模块改变了相应的值，也能获取到新的值，但不能直接改变这个值。(只读实时绑定)\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## 命名导出\n在变量、常量、函数和类声明时导出\n导出声明之后的标识符列表\n不能直接导出值\n在同一模块中导出的名称必须唯一。\n\n导出的位置不必与创建位置相同，可以独立导出声明,也独立使用多个声明。\n\n导入与解构的语法完全独立的，导入不允许嵌套，处理重命名的方式与解构不同，并且不允许默认值。\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "`export default x`  vs `{ default as x }`"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 重新导出另一个模块的导出\n\n聚合模块 会将模块的所有代码加载进来   \n`export * `不导出模块的默认导出，仅导出命名导出。  \n重新导出操作只是创建了导出，不会将内容导入到重新导出它的模块作用域内。需要同时导入和导出，可以分别执行。重新导出时可以使用as子句重命名导出。\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## 重命名导入 \n使用as子句重命名可能存在冲突的从其他模块的导入。  \n导入默认导入时，总是使用自定义名称，因此它和as子句不相关。但导入默认导出也可以采用重命名的形式。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "## 导入模块的命名空间对象\n\n模块命名空间对象时一个具有所有模块导出属性的对象(如果有默认导出，它的属性名则是default)。在第一被调用时构造成具有模块所有导出属性的对象(如果不被调用则不会构造)。如果源模块更改其导出值，则命名空间对象的属性值则随之动态更新。一旦模块命名空间对象被构造出来，如果其他模块也导入了该模块的命名空间对象，则该对象会被重用。模块命名空间对象是只读的，不能写入属性值，也不能添加或删除属性。  \n`* as mod`表示导入模块的命名空间对象并将其与本地标识符mod关联(绑定)。\n\n`import * as mod from xxx`\n"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "### 导出另一个模块的命名空间对象  \n模块可提供指向另一个模块的命名空间对象的导出。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "##  仅为副作用导入模块\n导入模块(顶层代码)而不从中导入任何内容，仅加载和运行它。"
            ],
            "outputs": []
        },
        {
            "language": "markdown",
            "source": [
                "导入和导出条目列表\n引擎解析一个模块时构建一个模块的导入条目列表和一个导出条目列表，用来描述模块加载和链接。但是代码不能直接访问。\n\n导入条目列表描述了它导入的内容，每个条目包含三个字段：[[ModuleRequest]]、[[ImportName]]、[[LocalName]]\nimport 'mod'不会创建导入条目，会创建另一个单独列表。\n\n导出条目列表描述了它导出的内容，包含四个字段: [[ExportName]]、[[LocalName]]、[[ImportName]]、[[ModuleRequest]]。"
            ],
            "outputs": []
        }
    ]
}