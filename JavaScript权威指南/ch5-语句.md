# 语句

## 表达式语句

- 赋值语句 (修改变量值)
- 函数调用语句 （改变环境或程序状态）

## 复合语句和空语句

大括号包裹的多个语句组成的语句块。块中的每条语句都以分号结尾，但是块本身没有。复合语句允许我们在在期待一个语句时使用多个语句。

空语句是只包含分号的语句，可以让我们在期待一条语句的地方不包含任何语句。

## 条件语句 （选择执行）

1. if/else

2. else if

3. switch

   switch 表达式与 case 表达式使用全等进行匹配，通常 case 表达式使用常量表达式。
   default:标签通常放置在末尾，但事实上可以出现在 switch 语句中的任何位置,但只有其他 case 子句都不匹配的时候才会执行 default:标签子句。

## 循环语句 （重复执行）

1. while
2. do/while 循环体至少执行一次，必须以分号终止。
3. for

- 初始化循环变量 执行一次
- 测试循环条件 每次执行
- 改变循环变量 执行多次

4. for/of 循环可迭代对象的元素 of 后面的表达式只求值一次
5. for await/of
6. for/in 循环遍历对象的可枚举属性 若`in`后面的表达式求值不为对象则跳过。

- 不会枚举符号属性
- 不会枚举不可枚举属性
- 可以枚举继承的可枚举属性
- 在循环体中删除尚未被枚举的属性，则该属性就不会再被枚举。若在循环体中在对象又定义了新的属性，则新的属性可能会(也可能不会)被枚举。

## 跳转语句

- 语句标签
  标识符后加`:`放在语句前面可以给任何语句加标签，可以在程序的任何地方通过标签引用它。任何语句都可以有标签，但只有给那些有语句体的语句加标签才有意义。break 和 continue 是 js 中唯一使用语句标签的语句。
  语句标签只有在定义它的语句中有效。如果一条语句被另外一条语句包含，那么他们不能使用相同的标签；如果两条语句没有嵌套关系，那么它们可以使用相同的标签。已经有标签的语句本身也可以再加标签，也就是任何语句都可以有多个标签。
- break
- continue

## 严格模式 "use strict"

指令与常规语句的区别:

- 不包含任何语言关键字；
- 只能出现在脚本或函数体开头，位于其他真正语句之前。

指令是由特定字符串字面量构成的表达式语句。

- 如果函数体是在严格代码中定义，或者函数体中是使用了"use strict"指令，那么它就是严格代码；
- 如果在严格代码中调用 eval(),那个传给 eval()的代码也是严格代码；
- 如果传给 eval()的字符串包含"use strict"指令，那相应的代码也是严格代码；
- `任何 class 体或 ES 模块中的代码全部默认为严格代码`。

严格模式修复了重要的语言缺陷，提供了更强的错误检查，也增强了安全性,并且不是默认的，可以让使用了具有缺陷的遗留特性的代码依然可以正确运行。

严格模式与非严格模式的区别：

- 不允许使用 with 语句；
- 所有变量必须显式声明；
- `函数调用 this 值为 undefind,而不是全局对象。如果函数通过 call()或 apply()调用，则 this 的值为传给它们的第一个参数(非严格模式下,null 和 undefined 回被替换成全局对象，非对象值会被转换为对象)`。
- `不能给不可写的属性赋值，不能给不可扩展的对象创建新属性`；
- 传给 eval()的代码不能像非严格模式那样在调用者的作用域中创建变量或声明函数，而是在 eval()创建的新作用域中创建，这个作用域在 eval()返回时就销毁。
- `严格模式下，函数中的 argument 对象保存的是传给函数值的静态副本，非严格模式下 arguments 对象元素与函数参数的命名参数引用相同值`。
- delete 操作符后跟未限定的标识符会抛 SyntaxError；
- delete 删除不可配置属性抛 TypeError；
- 对象字面量上定义同名属性抛语法错误；
- 函数中声明同名参数报语法错误；
- 不允许使用以 0 开头后面没有 x 的八进制字面量；
- eval 和 arguments 被作为关键字,不允许修改它们的值，不可用做标识符；
- 检查调用栈的能力受限。使用 arguments.caller 和 arguments.callee 会抛 TypeError。读取函数的 caller 和 arguments 属性会抛 TypeError。

函数声明会提升，而类声明不会。
