类型是值的内部特征，它定义了值的行为，以使其区别于其他值。在JS中内置的类型有一下七种：
1. null
2. undefined
3. boolean
4. number
5. string
6. symbol
7. object

可以使用typeof操作符来检测值的类型,但是它的字符串值并不都与这七种类型对应。
在JS中变量没有类型，只有值才有，变量可以随时持有任何类型的值。

undefined与undeclared
undefined 变量声明了，但未赋值
typeof检测未声明的变量返回值也是undefined,这是因为typeof有个特殊的安全防范机制。

## 数组 
与其他强类型的语言不同，在JS中，数组可以存储任意类型的值，可以是数字、字符串、布尔值、对象，甚至还可以是其他数组。另外对数组声明可以预先设定大小。

注意：使用`delete`操作符可以删除数组中的元素，但是数组的`length`属性并不会发生变化。


数组可以通过数字进行索引，也可通过字符串键和属性。但是对于能够强制转换成十进制整数的字符串键值会被当做数字来处理，并会影响数组的length属性，其他情况却不会。

稀疏数组：存在大量(过半)空缺或空白的数组。

类数组： 类似数组但不是真正的数组的对象，即具有length属性，可以通过数字进行索引的对象。常见的类数组对象有：arguments对象，字符串。

构造函数：
Array() 只传一个数值类型的参数会被当做数组预设长度而非数组第一个元素，如果这个数值不是正整数将会报错。

数组方法：
+ Array.from(args) 将参数列表转为数组


## 字符串 
`不可变`，类数组，具有`length`属性以及indexOf()和concat()方法。
面试题： 字符串反转 


## 原生函数 
原生函数也叫内建函数，大多数原生函数可以用做构造函数，但是没有null和undefined对应的构造函数。
常用的原生函数有：
+ String()
+ Number()
+ Boolean()
+ Symbol()
+ Array()
+ Object()
+ Function()
+ RegExp()
+ Date()
+ Error()

# 内部属性[[class]] 
Object.prototype.toString.call(value) 查看值的内部属性

封装对象
基本类型的值并没有属性和方法，JS引擎会自动将基本类型的值封装成对象。直接使用封装对象来“提前优化”代码反而会降低执行效率。因为JS引擎对这些常用情况一般都做了优化，所以一般不建议使用封装对象。

拆封
对于封装对象想要获取其基本类型的值，可以调用`valueOf()`方法。

除非必须需要，否则不要使用Array()/Object()/Function()/RegExp()。但是在动态构建正则表达式或函数时，RegExp()和Function()就可以派上用场。

相比其他原生构造函数，Date()和Error()的用处大得因为没有对应的常量形式。
创建日期对象必须new Date(...)，可以带参数指定日期和时间，如果不带参数，则使用当前日期和时间。

时间戳获取(以秒为单位)：
+ new Date().getTime()
+ Date.now() (ES6新增静态函数)

构造函数Error()主要用于创建错误对象，获取当前运行栈的上下文。栈的上下文信息通过只读属性`stack`来访问。一般包含函数调用栈信息和产生错误代码的行号。通常错误对象至少包含一个`message`属性,有时还有其他属性，如`type`属性。最好通过调用`toString`方法来获取经过格式化的便于阅读的错误信息。

## Symbol()
具有唯一的特殊值，可以用来命名对象属性不容易导致重名。但是它`不能通过new 关键字来调用`。ES6中有一些预定义符号以Symbol的静态属性形式存在。虽然符号并非私有属性，但它却主要用于私有或特殊属性。Symbol并非对象，而是一种简单标量基本类型。

获取对象上的所有Symbol属性： Object.getOwnPropertySymbols()

## 原生原型 
原生构造函数有自己的原型对象，可以通过`prototype`访问。这些原型对象包含其对应子类型所特有的行为特征。一般不要修改原型对象。
